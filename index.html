<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Hex Game ‚Äî Multiplayer (PWA-ready)</title>
<style>
  html,body{height:100%;margin:0;background:#14151a;font-family:Arial, Helvetica, sans-serif}
  #game{display:block;margin:0 auto;background:#14151a;touch-action:none}
  .note{position:fixed;left:8px;bottom:8px;color:#ccc;font-size:12px}
</style>
</head>
<body>
<canvas id="game" width="1000" height="700"></canvas>
<div class="note">Tip: run the provided server.js and open this page. Works offline as PWA after install.</div>
<script>
/* Hex Game ‚Äî single-file PWA-ready client (updated)
   - Adds player-count selection (2/3/4) near Create
   - Shows servers list (rooms) with Join buttons
   - Displays trophy overlay on server 'game_over' then returns to lobby
*/

// --- Constants (keep in sync with server) ---
const R = 4;      // grid radius
const STEP = 4;   // required path length
const SP = 60;    // spacing
const DR = 10;    // dot radius
const STEP_POINTS = 4; // step variable name to match original
const WIDTH = 1000, HEIGHT = 700;

// Colors & fonts
const BG = '#14171b';
const DOT = '#222629';
const LINE_COLOR = '#ffffff';
const PLAYERS_COLORS = [ '#ff0000', '#ffff00', '#00ff00', '#0000ff' ];
const FONT = '22px Arial';
const BIG_FONT = '64px Arial';

// Canvas
const canvas = document.getElementById('game');
canvas.width = WIDTH; canvas.height = HEIGHT;
const ctx = canvas.getContext('2d');
ctx.textBaseline = 'top';

// Grid construction (q,r) points and index map
const pts = []; // {pos:[x,y], q, r}
const idx = {}; // "q,r"->index
(function buildGrid(){
  for (let q = -R+1; q < R; q++){
    const r1 = Math.max(-R+1, -q-R+1);
    const r2 = Math.min(R-1, -q+R-1);
    for (let rr = r1; rr <= r2; rr++){
      const pos = toxy(q,rr);
      idx[`${q},${rr}`] = pts.length;
      pts.push({ pos, q, r: rr });
    }
  }
})();

function toxy(q,r){
  const x = SP*(1.5*q);
  const y = SP*(Math.sqrt(3)*(r + q/2));
  return [ Math.round(x + WIDTH/2), Math.round(y + HEIGHT/2 + 40) ];
}

// Game state
let con = []; // list of [a,b] with a<b
let tris = []; // list of {points:[a,b,c], owner}
let sel = null; let turn = 0;
let moves = [15,15,15,15]; let score = [0,0,0,0];
let game_over = false; let winner = null;
let tri_delay = 400; // ms
let animating = false; let waiting_for_server = false;

// Lobby state
let room_chosen = null; let player_index = null; let is_host = false; let lobby_players = [];
let input_active = null; let input_name = 'Player'; let input_room = 'room1';

// UI: selected player count (2/3/4)
let selectedPlayerCount = 4;

// Servers list data
let servers = []; // [{id, players, started, minPlayers, maxPlayers}]
let serversButtonRects = []; // store Join button rects for hit testing
let serversRefreshInterval = null;

// Winner overlay
let showWinnerOverlay = false;
let winnerOverlayData = null; // {winnerName, emoji}
let winnerOverlayTimeout = null;

// Mouse interaction
let dragging = false; let drag_pos = null;

// --- Drawing helpers ---
function drawHexagon(ctx, color, center, radius, fill=true, width=0){
  ctx.beginPath();
  for (let i=0;i<6;i++){
    const ang = (Math.PI/180) * (60*i - 30);
    const x = center[0] + radius * Math.cos(ang);
    const y = center[1] + radius * Math.sin(ang);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  if (fill) ctx.fillStyle = color, ctx.fill();
  if (width>0) ctx.lineWidth = width, ctx.strokeStyle = LINE_COLOR, ctx.stroke();
}

function drawLine(ctx, a, b, thickness=4){
  ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineWidth = thickness; ctx.strokeStyle = LINE_COLOR; ctx.stroke();
}

function drawPlayerPanels(){
  const pad = 10; const box_w = 220, box_h = 80;
  const positions = [ [pad,pad], [WIDTH-box_w-pad,pad], [pad,HEIGHT-box_h-pad], [WIDTH-box_w-pad,HEIGHT-box_h-pad] ];
  ctx.font = FONT; ctx.textBaseline='top';
  for (let i=0;i<4;i++){
    const [x,y] = positions[i];
    const color = PLAYERS_COLORS[i];
    const active = (i === turn);
    const disabled = (score[i] >= 15 || moves[i] <= 0);
    const rect_color = disabled ? '#3c3c46' : (active ? shadeColor(color,40) : '#323238');
    // box
    roundRect(ctx,x,y,box_w,box_h,10,true,rect_color);
    ctx.lineWidth = 3; ctx.strokeStyle = color; roundRect(ctx,x,y,box_w,box_h,10,false); // border
    ctx.fillStyle = '#fff';
    ctx.fillText(`P${i+1}`, x+10, y+8);
    ctx.fillText(`–û—á–∫–∏: ${score[i]}`, x+10, y+40);
  }
}

function shadeColor(hex, amt){
  // hex like #rrggbb, amt positive to lighten
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  let r = (num >> 16) + amt; if (r>255) r=255; if(r<0) r=0;
  let g = ((num >> 8) & 0x00FF) + amt; if (g>255) g=255; if(g<0) g=0;
  let b = (num & 0x0000FF) + amt; if (b>255) b=255; if(b<0) b=0;
  return `rgb(${r},${g},${b})`;
}

function roundRect(ctx,x,y,w,h,r, fill=false, fillStyle='#000'){
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  if (fill){ ctx.fillStyle = fillStyle; ctx.fill(); }
  else ctx.stroke();
}

// === Small Hex Pattern helpers ===
function drawFrame(sel_local=null, dragPos=null, temp_centers=null){
  ctx.fillStyle = BG;
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // edges
  ctx.lineWidth = 4;
  ctx.strokeStyle = LINE_COLOR;
  for (const [a,b] of con){
    drawLine(ctx, pts[a].pos, pts[b].pos, 4);
  }

  // triangles ‚Äî now just small dot in the middle
  for (const tri of tris){
    try{
      const ptsList = tri.points.map(i=>pts[i].pos);
      const color = PLAYERS_COLORS[tri.owner] || PLAYERS_COLORS[0];

      // center of triangle
      const cx = (ptsList[0][0] + ptsList[1][0] + ptsList[2][0]) / 3;
      const cy = (ptsList[0][1] + ptsList[1][1] + ptsList[2][1]) / 3;

      // draw small hex or circle (your choice)
      drawHexagon(ctx, color, [cx, cy], 8, true);
    }catch(e){ }
  }

  // temp centers for animation
  if (temp_centers){
    for (const [center, color] of temp_centers){
      drawHexagon(ctx, color, center, 10, true);
    }
  }

  // points
  for (const p of pts){
    drawHexagon(ctx, DOT, p.pos, DR, true);
  }

  // dragging preview
  if (sel_local !== null && dragPos){
    drawLine(ctx, pts[sel_local].pos, dragPos, 4);
  }

  drawPlayerPanels();

  // If winner overlay active, render it above
  if (showWinnerOverlay && winnerOverlayData){
    const bgAlpha = 0.86;
    ctx.fillStyle = `rgba(0,0,0,${bgAlpha})`;
    ctx.fillRect(0,0,WIDTH,HEIGHT);
    ctx.font = '48px Arial';
    ctx.fillStyle = '#fff';
    const text = `${winnerOverlayData.emoji || 'üèÜ'}  –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winnerOverlayData.winnerName || ('P' + (winner+1))}`;
    const w = ctx.measureText(text).width;
    ctx.fillText(text, WIDTH/2 - w/2, HEIGHT/2 - 24);
  }
}

// --- Utilities ---
function near(pos){
  for (let i=0;i<pts.length;i++){
    const p = pts[i].pos; const dx = p[0]-pos[0], dy = p[1]-pos[1];
    if (dx*dx + dy*dy <= (DR+8)*(DR+8)) return i;
  }
  return null;
}

function sortedPair(a,b){ return a<b ? [a,b] : [b,a]; }

// Equivalent of line_ok in Python: returns array of indices or []
function line_ok(a,b){
  const p1 = pts[a], p2 = pts[b];
  const q1 = p1.q, r1 = p1.r, q2 = p2.q, r2 = p2.r;
  const d = Math.max(Math.abs(q1-q2), Math.abs(r1-r2), Math.abs((q1+r1)-(q2+r2)));
  if (d===0) return [];
  if (!((q1-q2===0) || (r1-r2===0) || ((q1+r1)-(q2+r2)===0))) return [];
  const dq = (q2-q1)/d, dr = (r2-r1)/d;
  const path = [];
  for (let i=0;i<=d;i++){
    const q = Math.round(q1 + dq*i), r = Math.round(r1 + dr*i);
    const key = `${q},${r}`;
    if (key in idx) path.push(idx[key]); else return [];
  }
  return path;
}

function find_triangles_local(){
  const found = [];
  const edgesSet = new Set(con.map(e=>`${e[0]}-${e[1]}`));
  const n = pts.length;
  for (let a=0;a<n;a++){
    for (let b=a+1;b<n;b++){
      if (!edgesSet.has(`${a}-${b}`)) continue;
      for (let c=b+1;c<n;c++){
        if (edgesSet.has(`${b}-${c}`) && edgesSet.has(`${a}-${c}`)) found.push([a,b,c]);
      }
    }
  }
  return found;
}

function tri_center(tri_pts){
  const xs = tri_pts.map(p=>p[0]); const ys = tri_pts.map(p=>p[1]);
  return [ Math.floor((xs[0]+xs[1]+xs[2])/3), Math.floor((ys[0]+ys[1]+ys[2])/3) ];
}

function end_if_needed(){
  const active_players = [];
  for (let i=0;i<4;i++) if (moves[i] > 0 && score[i] < 15) active_players.push(i);
  if (active_players.length <= 1){ game_over = true; winner = score.indexOf(Math.max(...score)); return true; }
  return false;
}

function next_turn_local(){
  for (let i=0;i<4;i++){ turn = (turn+1)%4; if (moves[turn] > 0 && score[turn] < 15) break; }
}

// animate triangle centers sequentially
async function animateTriangleCenters(new_tris_list){
  animating = true;
  const temp = [];
  for (const item of new_tris_list){
    temp.push([item.center, item.color]);
    drawFrame(null,null,temp);
    await new Promise(resolve => setTimeout(resolve, tri_delay));
  }
  animating = false;
}

// --- WebSocket client ---
const WS_URL = 'wss://frosty-colden.185-234-114-50.plesk.page';
class WSClient {
  constructor(url){ this.url = url; this.ws = null; this.queue = []; this.connected = false; }
  connect(){
    return new Promise((res,rej)=>{
      try{
        this.ws = new WebSocket(this.url);
        this.ws.addEventListener('open', ()=>{ this.connected = true; console.log('WS open'); res(); });
        this.ws.addEventListener('message', e=>{ try{ const d=JSON.parse(e.data); this.queue.push(d); console.log('SERVER MSG:', d);}catch(err){} });
        this.ws.addEventListener('close', ()=>{ this.connected = false; this.queue.push({type:'closed'}); console.log('WS closed'); });
        this.ws.addEventListener('error', (err)=>{ console.error('WS error',err); });
      }catch(e){ rej(e); }
    });
  }
  send(obj){ if (this.ws && this.connected) this.ws.send(JSON.stringify(obj)); }
  recv_nowait(){ return this.queue.length ? this.queue.shift() : null; }
}
const ws_client = new WSClient(WS_URL);

// Request rooms list
function requestRoomsList(){
  if (ws_client.connected) ws_client.send({ type: 'list_rooms' });
}

// handle server messages
async function handle_server_messages(){
  const data = ws_client.recv_nowait(); if (!data) return;
  const t = data.type;
  if (t === 'created'){
    room_chosen = data.room;
    player_index = data.playerIndex;
    // server returns min/max ‚Äî keep them if needed
    console.log('created', room_chosen, player_index);
  } else if (t === 'joined'){
    room_chosen = data.room;
    player_index = data.playerIndex;
    console.log('joined', room_chosen, player_index);
  } else if (t === 'lobby'){
    lobby_players = data.players || [];
    const hostIndex = (typeof data.hostIndex !== 'undefined') ? data.hostIndex : 0;
    is_host = (player_index === hostIndex);
  } else if (t === 'start'){
    con = [];
    tris = [];
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = (typeof data.game_over !== 'undefined') ? data.game_over : false;
    winner = (typeof data.winner !== 'undefined') ? data.winner : null;
    waiting_for_server = false;
  } else if (t === 'state_update'){
    // authoritative edges/tris/state
    try { con = (data.con || []).map(pair => [pair[0], pair[1]]); } catch(e){ con = []; }
    if (Array.isArray(data.tris)){
      tris = data.tris.map(tr => ({ points: tr.points.slice(), owner: tr.owner }));
    } else {
      const new_tris = data.new_tris || [];
      for (const tr of new_tris){
        const pts_trip = tr.points.slice();
        const owner = tr.owner;
        if (!tris.find(t=>arraysEqual(t.points.slice().sort(), pts_trip.slice().sort()))){
          tris.push({points:pts_trip, owner});
        }
      }
    }
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = (typeof data.game_over !== 'undefined') ? data.game_over : game_over;
    winner = (typeof data.winner !== 'undefined') ? data.winner : winner;
    waiting_for_server = false;
  } else if (t === 'rooms_list'){
    // update local servers list
    servers = Array.isArray(data.rooms) ? data.rooms : [];
  } else if (t === 'game_over'){
    // server announces the winner and optional emoji
    showWinnerOverlay = true;
    winnerOverlayData = { winnerName: data.winnerName || null, emoji: data.emoji || 'üèÜ' };
    // show overlay for few seconds, then return to lobby (clear room_chosen)
    if (winnerOverlayTimeout) clearTimeout(winnerOverlayTimeout);
    winnerOverlayTimeout = setTimeout(()=>{
      showWinnerOverlay = false;
      winnerOverlayData = null;
      // return to lobby view
      room_chosen = null;
      player_index = null;
      lobby_players = [];
      con = []; tris = [];
      score = [0,0,0,0]; moves = [15,15,15,15];
      requestRoomsList();
    }, 3000);
  } else if (t === 'closed'){
    // ws closed
    console.log('server closed connection');
  } else if (t === 'error'){
    console.warn('server error:', data.message);
  }
}

function arraysEqual(a,b){ if (a.length!==b.length) return false; for(let i=0;i<a.length;i++) if (a[i]!==b[i]) return false; return true; }

// --- Input handling (canvas) ---
canvas.addEventListener('mousemove', (ev)=>{
  const pos = canvasPos(ev); if (sel !== null && !animating && !waiting_for_server) drag_pos = [pos.x,pos.y];
});
canvas.addEventListener('mousedown', async (ev)=>{
  const pos = canvasPos(ev); const mx = pos.x, my = pos.y;
  // If in lobby (room_chosen===null and empty board)
  if (room_chosen === null && con.length===0 && tris.length===0){
    // Player name box
    if (50 <= mx && mx <= 350 && 120 <= my && my <= 160) { input_active = 'name'; return; }
    // Room box
    if (50 <= mx && mx <= 350 && 180 <= my && my <= 220) { input_active = 'room'; return; }

    // player-count buttons (drawn near create)
    // button positions match drawLobbyUI below: at x 540.. (three 40x36 buttons)
    if (520 <= mx && mx <= 720 && 120 <= my && my <= 160){
      // three buttons horizontally
      const bx = mx - 520;
      const idxBtn = Math.floor(bx / 66); // approx
      const mapping = [2,3,4]; // left->2, mid->3, right->4
      const sel = mapping[Math.max(0, Math.min(2, idxBtn))];
      selectedPlayerCount = sel;
      return;
    }

    // Create button (380..520 x 120..160)
    if (380 <= mx && mx <= 520 && 120 <= my && my <= 160){
      if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
      // send create, include chosen playerCount so server knows how many to wait for
      ws_client.send({ type:'create', room: input_room, name: input_name, playerCount: selectedPlayerCount });
      return;
    }

    // Join button for manual room (380..520 x 180..220)
    if (380 <= mx && mx <= 520 && 180 <= my && my <= 220){
      if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
      ws_client.send({ type:'join', room: input_room, name: input_name });
      return;
    }

    // Start button (host)
    if (800 <= mx && mx <= 940 && 120 <= my && my <= 160 && is_host && room_chosen){
      ws_client.send({ type:'start', room: room_chosen });
      return;
    }

    // Servers list join buttons (rendered on right area). Check hit against stored rects
    for (let i=0;i<serversButtonRects.length;i++){
      const r = serversButtonRects[i];
      if (mx >= r.x && mx <= r.x+r.w && my >= r.y && my <= r.y+r.h){
        // join that server by id
        const roomId = servers[i].id;
        if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
        ws_client.send({ type:'join', room: roomId, name: input_name });
        return;
      }
    }

    return;
  }

  // Gameplay click handling (unchanged)
  if (animating || waiting_for_server) return;
  if (game_over) return;
  if (score[turn] >= 15 || moves[turn] <= 0){ next_turn_local(); return; }
  const i = near([mx,my]);
  if (i !== null){
    if (sel === null){ sel = i; drag_pos = [mx,my]; }
    else if (i !== sel){
      const path = line_ok(sel, i);
      if (path.length === STEP_POINTS){
        let made_line=false;
        for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge = sortedPair(a,b); if (!con.find(e=>e[0]===edge[0]&&e[1]===edge[1])) made_line=true; }
        if (made_line){
          if (ws_client.connected && room_chosen !== null){ waiting_for_server = true; try{ ws_client.send({ type:'make_move', room: room_chosen, path: path }); }catch(err){ console.error('send move failed',err); waiting_for_server=false; } }
          else { // local-only
            for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge = sortedPair(a,b); if (!con.find(e=>e[0]===edge[0]&&e[1]===edge[1])) con.push(edge); }
            const all_tris = find_triangles_local();
            const existing_sets = new Set(tris.map(t=>t.points.slice().sort((a,b)=>a-b).join(',')));
            const new_tris_raw = all_tris.filter(t => !existing_sets.has(t.slice().sort((a,b)=>a-b).join(',')));
            const new_tris = [];
            for (const t of new_tris_raw){ const tri_pts = [ pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos ]; const center = tri_center(tri_pts); new_tris.push({ points: t, center, color: PLAYERS_COLORS[turn] }); }
            if (new_tris.length){ await animateTriangleCenters(new_tris); for (const nt of new_tris){ tris.push({ points: nt.points, owner: turn }); score[turn]++; } }
            moves[turn]--; if (!end_if_needed()) next_turn_local();
          }
        }
      }
      sel=null; drag_pos=null;
    }
  }
});

// keyboard for lobby input
window.addEventListener('keydown', (ev)=>{
  if (room_chosen === null && con.length===0 && tris.length===0 && input_active){
    if (ev.key === 'Backspace'){
      if (input_active === 'name') input_name = input_name.slice(0,-1);
      else input_room = input_room.slice(0,-1);
    } else if (ev.key === 'Enter') input_active = null;
    else if (ev.key.length === 1){ if (input_active === 'name') input_name += ev.key; else input_room += ev.key; }
  }
});

function canvasPos(ev){
  const rect = canvas.getBoundingClientRect(); return { x: Math.round((ev.clientX-rect.left)*(canvas.width/rect.width)), y: Math.round((ev.clientY-rect.top)*(canvas.height/rect.height)) };
}

// Render lobby UI including player-count buttons and servers list
function drawLobbyUI(){
  ctx.fillStyle = '#1e1e24'; ctx.fillRect(0,0,WIDTH,HEIGHT);
  ctx.font = '64px Arial'; ctx.fillStyle = '#fff'; const title = 'Lobby'; ctx.fillText(title, WIDTH/2 - ctx.measureText(title).width/2, 20);

  // name box
  ctx.fillStyle = '#32323c'; roundRect(ctx,50,120,300,40,6,true); ctx.strokeStyle = '#c8c8c8'; ctx.lineWidth=2; roundRect(ctx,50,120,300,40,6,false);
  ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Name: ' + input_name, 60, 128);
  // room box
  ctx.fillStyle = '#32323c'; roundRect(ctx,50,180,300,40,6,true); ctx.strokeStyle = '#c8c8c8'; roundRect(ctx,50,180,300,40,6,false);
  ctx.fillStyle = '#fff'; ctx.fillText('Room: ' + input_room, 60, 188);

  // player-count buttons (2/3/4) near Create
  const pcX = 520, pcY = 120, pcW = 66, pcH = 36;
  ctx.fillStyle = '#222'; ctx.font = FONT;
  const counts = [2,3,4];
  for (let i=0;i<counts.length;i++){
    const x = pcX + i*(pcW + 6);
    const y = pcY;
    const isSel = (counts[i] === selectedPlayerCount);
    roundRect(ctx,x,y,pcW,pcH,6,true, isSel ? '#3cc078' : '#444');
    ctx.fillStyle = isSel ? '#000' : '#fff';
    ctx.fillText(String(counts[i]), x + pcW/2 - ctx.measureText(String(counts[i])).width/2, y+6);
  }
  ctx.font = FONT;

  // create/join buttons
  ctx.fillStyle = '#4682b4'; roundRect(ctx,380,120,140,40,6,true); roundRect(ctx,380,180,140,40,6,true);
  ctx.fillStyle = '#fff'; ctx.fillText('Create', 405,128); ctx.fillText('Join', 415,188);

  // player list (players in current room if any)
  ctx.fillStyle = '#fff'; ctx.fillText('Players in room:', 50,250);
  let y = 290; ctx.font = FONT; for (const p of lobby_players){ const flag = p.isHost ? ' (host)' : ''; ctx.fillStyle = '#e6e6e6'; ctx.fillText(`${p.index+1}. ${p.name}${flag}`, 60, y); y += 30; }
  if (is_host && room_chosen){ ctx.fillStyle = '#3cc078'; roundRect(ctx,800,120,140,40,6,true); ctx.fillStyle = '#000'; ctx.fillText('Start', 830,128); }

  // servers list on right
  ctx.fillStyle = '#fff'; ctx.fillText('Servers:', 520, 220);
  serversButtonRects = [];
  let sy = 260;
  ctx.font = '18px Arial';
  for (let i=0;i<servers.length;i++){
    const s = servers[i];
    // row background
    roundRect(ctx,520, sy, 440, 40, 6, true, '#2a2a33');
    ctx.fillStyle = '#fff';
    const label = `${s.id} ‚Äî players: ${s.players} (${s.minPlayers}/${s.maxPlayers}) ${s.started ? '[started]' : ''}`;
    ctx.fillText(label, 530, sy+10);
    // join button on this row
    const bx = 880, by = sy+6, bw = 70, bh = 28;
    roundRect(ctx,bx,by,bw,bh,6,true, '#4682b4');
    ctx.fillStyle = '#fff'; ctx.fillText('Join', bx+18, by+4);
    serversButtonRects.push({ x: bx, y: by, w: bw, h: bh });
    sy += 54;
    if (sy > HEIGHT - 80) break;
  }
  ctx.font = FONT;
}

// --- Main loop ---
let lastTick = performance.now();
async function mainLoop(ts){
  // handle any server messages
  try{ await handle_server_messages(); }catch(e){}
  // draw
  if (room_chosen === null && con.length===0 && tris.length===0){
    drawLobbyUI();
  } else {
    drawFrame(sel, drag_pos);
    if (game_over){
      ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      ctx.font = BIG_FONT; ctx.fillStyle = '#fff';
      const txt = `–ü–û–ë–ï–î–ò–õ –ò–ì–†–û–ö ${winner+1}!`;
      const w = ctx.measureText(txt).width; ctx.fillStyle = '#fff'; ctx.fillText(txt, WIDTH/2 - w/2, HEIGHT/2 - 32);
    }
  }
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

// --- Start: try connect (non-blocking) and start room polling ---
(async ()=>{ try{ await ws_client.connect(); requestRoomsList(); }catch(e){ console.warn('initial ws connect failed',e); } })();

// Poll servers list every 5s while in lobby (room_chosen === null)
setInterval(()=>{
  if (ws_client.connected && room_chosen === null) requestRoomsList();
}, 5000);

// --- Self-contained PWA registration (service worker & manifest created from Blobs) ---
if ('serviceWorker' in navigator){
  const swScript = `self.addEventListener('install',e=>{self.skipWaiting();});self.addEventListener('activate',e=>{clients.claim();});self.addEventListener('fetch',e=>{if (e.request.url.endsWith('/ws')) return; e.respondWith(fetch(e.request));});`;
  const swBlob = new Blob([swScript],{type:'application/javascript'});
  const swUrl = URL.createObjectURL(swBlob);
  navigator.serviceWorker.register(swUrl).then(()=>console.log('sw registered from blob')).catch(e=>console.warn('sw reg failed',e));
  // manifest
  const manifest = {
  name: 'Hex Game',
  short_name: 'HexGame',
  start_url: '.',
  display: 'standalone',
  icons: [
    {
      src: 'https://testingapp-dot.github.io/chesspygame/favicon.png',
      sizes: '512x512',
      type: 'image/png'
    }
  ]
};

const manBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
const manUrl = URL.createObjectURL(manBlob);
const link = document.createElement('link');
link.rel = 'manifest';
link.href = manUrl;
document.head.appendChild(link);
}

// --- helpers / debug ---
function logState(){ console.log({con, tris, score, moves, turn, room_chosen, player_index, servers}); }

</script>
</body>
</html>
